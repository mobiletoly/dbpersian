{"name":"DBPersian","tagline":"Database Persistence Annotations for Android","body":"## DBPersian - Database Persistence Annotations for Android\r\nDBPersian is a simple and elegant framework to help you to deal with a routine tasks such as database access. This is a pretty thin layer in between SQLite database and Android application, mostly designed to provide a convenient way to serialize/deserialize entities to/from SQLite database based on Java annotations. The primary goal is to keep developer as close to the database as possible while getting rid of some burden and boilerplate code. Also performance is a key consideration for DBPersian, so no reflections and other relatively slow approaches, everything is done via generating code in compile time, so hopefully your code will be as fast as if you would write it by yourself.\r\n\r\nAlright, let's get down to business. The following tutorial assumes that you are using Android Studio with gradle for your development. We are going to write a simple Music Collection application, that will help you to start using DBPersian and will show you a best practices at the same time. We are going to use a step-by-step approach.\r\n\r\nYou can create a new Android project or just simply take a look at [demo code](https://github.com/mobiletoly/dbpersian/tree/master/android/TestApp) repository which we have tried to keep as simple as possible.\r\n\r\n### Gradle build file\r\n\r\nAt first let's take a look how is [gradle file](https://github.com/mobiletoly/dbpersian/blob/master/android/TestApp/app/build.gradle) looks like\r\n\r\n    ...\r\n    // We need APT plugin to perform compile-time annotations processing\r\n    buildscript {\r\n        repositories {\r\n            mavenCentral()\r\n        }\r\n        dependencies {\r\n            // --- DBPersian uses APT (annotation processor)\r\n            // so we have decided to use android-apt plugin\r\n            classpath 'com.neenbedankt.gradle.plugins:android-apt:1.4'\r\n        }\r\n        ...\r\n    }\r\n\r\n    apply plugin: 'com.android.application'\r\n    // --- Apply APT plugin\r\n    apply plugin: 'com.neenbedankt.android-apt'\r\n\r\n    android {\r\n        ...\r\n    }\r\n\r\n    \r\n    dependencies {\r\n        repositories {\r\n            ...\r\n            mavenCentral()\r\n        }\r\n\r\n        compile fileTree(dir: 'libs', include: ['*.jar'])\r\n\r\n        // --- Add dbpersian dependencies\r\n        compile 'net.dbpersian:api:0.5'\r\n        provided 'net.dbpersian:builder:0.5'\r\n        apt 'net.dbpersian:builder:0.5'\r\n    }\r\n\r\n### Entity models\r\n\r\nNow when all dependencies are in place, we want to start creating a models for our Music collection. All you have to do is to create a regular Java's class and annotate it with a @DbTable annotation, this will tell to DBPersian to generate a code to create/open table to be capable of storing instance of this class. For our demo project we need three models: [Genre](https://github.com/mobiletoly/dbpersian/blob/master/android/TestApp/app/src/main/java/net/dbpersian/testapp/music/Genre.java), Â [Artist](https://github.com/mobiletoly/dbpersian/blob/master/android/TestApp/app/src/main/java/net/dbpersian/testapp/music/Artist.java), and [Album](https://github.com/mobiletoly/dbpersian/blob/master/android/TestApp/app/src/main/java/net/dbpersian/testapp/music/Album.java) (that has a reference to Artist and Genre).\r\n\r\nHere is an Artist class:\r\n\r\n    @DbTable(sqlName = \"artist\")\r\n    public class Artist\r\n    {\r\n        // This field is a primary key column. It is unique and automatically assigned by SQLite\r\n        @DbColumn(sqlName = \"id\", primaryKey = true)\r\n        Long id;\r\n\r\n        // Text field to hold a name of an artist.\r\n        @DbColumn(sqlName = \"name\", indexName = \"idx_artist_name\", unique = true, notNull = true)\r\n        String name;\r\n\r\n        public Long getId() { return id; }\r\n\r\n        public String getName() { return name; }\r\n        public void setName(String name) { this.name = name; }\r\n\r\n        // ... equals and hashCode methods\r\n    }\r\n\r\n@DbTable annotation with sqlName parameter instructs DBPersian to create a table \"artist\" inside a SQLite database. \"id\" field has an annotation @DbColumn with primaryKey attribute equals to \"true\". It ensures that table has a [primary key](https://www.sqlite.org/lang_createtable.html) and values are auto-assigned by SQLite. That is why getId() getter method, but don't have a setter, because DBersian takes care of creating a unique \"id\" field, so you don't need to assign \"id\" field, it's already taken care of. At this point you might be surprised why we don't declare \"private Long id\" instead of \"Long id\". Reasons is simple, DBPersian generates a code that needs to have access to class fields. Please make sure that you have a package-level code access for instances you are planning to persist in your entity classes (don't use \"private\" modifier in your class for those fields).\r\nField \"name\" has a @DbColumn annotation that creates a table's column \"name\", ensures that column is indexed with \"idx_artist_name\" index (that will be created as well), field will be unique and must not be null.\r\n\r\n[Genre](https://github.com/mobiletoly/dbpersian/blob/master/android/TestApp/app/src/main/java/net/dbpersian/testapp/music/Genre.java) is pretty similar to Artist. \r\n\r\n### Foreign key\r\n\r\nLet's take a look at [Album](https://github.com/mobiletoly/dbpersian/blob/master/android/TestApp/app/src/main/java/net/dbpersian/testapp/music/Album.java) class. It is different from previous classes, because it contains references to both Artist and Genre (via SQL's foreign keys).\r\n\r\n    @DbTable(sqlName = \"album\")\r\n    public class Album\r\n    {\r\n        // This field is a primary key column. It is unique and automatically assigned by SQLite\r\n        @DbColumn(sqlName = \"id\", primaryKey = true)\r\n        Long id;\r\n    \r\n        // Text field to hold a name of an album.\r\n        @DbColumn(sqlName = \"name\", indexName = \"idx_album_name\", notNull = true)\r\n        String name;\r\n    \r\n        // This field is a foreign key to \"id\" column in Artist table.\r\n        @DbColumn(sqlName = \"artist_id\", fkTable = \"artist\", fkColumn = \"id\", notNull = true)\r\n        Long artistId;\r\n        // This field will be containing a deserialized Artist object referenced by foreign key value in artistId field\r\n        @DbForeignKeyReader(refField = \"artistId\")\r\n        Artist artist;\r\n    \r\n        @DbColumn(sqlName = \"genre_code\", fkTable = \"genre\", fkColumn = \"code\", indexName = \"fk_album_genrecode\")\r\n        String genreCode;\r\n        Genre genre;\r\n    \r\n        @DbColumn(sqlName = \"year\", indexName = \"idx_album_year\")\r\n        Integer yearReleased;\r\n    \r\n        @DbColumn(sqlName = \"description\")\r\n        String description;\r\n    \r\n        // Getters/setters\r\n        ...\r\n}\r\n\r\nLet's take a look at what is going on here. First two fields (\"id\", \"name\") are obvious, but third field (\"artistId\") is different. What @DbColumn does here is it creates a column \"artist_id\" and also creates a SQL's foreign key that refers to column \"id\" in table \"artist\". By using an artistId field you could manually query an instance of Artist class via ArtistDAO, but we want to simplify this task for you. That is why we have a @DbForeignKeyReader annotation. @DbForeignKeyReader is a convenient annotation that allows us to instruct DBPersian to query table \"Artist\" based on a value of foreign key stored in \"artistId\" field above. So what it actually does is performs something like \"SELECT * FROM artist_id WHERE id = :artistId\" and deserialize a result into the \"artist\" field. Querying for entities referred by a foreign keys is enabled automatically by default. If you want to disable this behaviour, you may choose to call\r\n    albumDAO.setAutoFetchForeignKeyReaders(false);\r\nIn this case querying of fields annotated with @DbForeignKeyReader will not be performed automatically. It might save you an extra database query and improve a performance (let's say at startup time), but later you can query for a foreign key entities manually. You can do it by calling:\r\n    final Album album = ...;\r\n    albumDao.fetchUserTaskGroup(album);\r\nor (to fetch all field annotated by @DbForeignKeyReader if you have more than one):\r\n    albumDao.fetchAllForeignKeyReaders(album);\r\n\r\nAlso it is important to mention that @DbForeignKeyReader is a \"one way street\", it works only for reading entities. E.g. if you have changed a data inside an Artist object of Album and then you try to save that Album entity to a database, then Artist entity will not be updated inside a database. You still have to save Artist entity manually, such as\r\n    album.setName(\"Different Album\");\r\n    album.artist.setName(\"Different Artist\");\r\n    albumDAO.update(album);\r\n    artistDAO.update(artist);    // yep, this one is required\r\n\r\n\r\n### Database helper\r\n\r\nWhat you want to do next is to create a database helper that allows you to handle things like opening database, upgrading database and most important - DBPersian will generate a code to take care of creating database based on schemas that you specify with annotations.\r\n\r\nLet's create a database helper file that takes care of creating/opening a database.\r\n\r\nSince we don't have any plugins for Android Studio yet, the next step is a little cumbersome. Let's create a class MusicDbHelper:\r\n\r\n    import net.dbpersian.annotations.db.Database;\r\n    ...\r\n    @Database(filename = \"music.db\")\r\n    public class MusicDbHelper { }\r\n\r\nand now it is time to rebuild a project (menu Build / Rebuild Project). If everything is OK then AbstractMusicDbHelper class will be generated for you. So this time we want to extend this class\r\n\r\n    import net.dbpersian.annotations.db.Database;\r\n    ...\r\n    @Database(filename = \"music.db\")\r\n    public class MusicDbHelper extend AbstractMusicDbHelper\r\n    {\r\n        ...\r\n    }\r\n\r\nTake a look at full implementation of this class: [here](https://github.com/mobiletoly/dbpersian/blob/master/android/TestApp/app/src/main/java/net/dbpersian/testapp/music/MusicDbHelper.java)\r\nThe most important part so far is a @Database annotation. It is very simple to use, just specify a database name via **filename** parameter and DBPersian will take care of generating a code for you to take care of operation suchs as creating and opening a SQLite database named \"music.db\".\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}